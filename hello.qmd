---
title: "How Do Password Characteristics Affect Password Strength?"
author: "Zaid Muqsit and Zoe Spicer"
geometry: "left=1.8cm,right=1.8cm,top=1.8cm,bottom=2cm"
format: pdf
editor_options: 
  chunk_output_type: console
---

\vspace{-2cm}

```{r load-data, message = F, warning = F, echo=FALSE}
library(tidyverse) 
library(tidymodels)
library(stringr)
library(stringi)
library(leaps)
library(gtsummary)
library(MASS)
library(glmnet)
library(Stat2Data)
library(caret)
library(gridExtra)
library(grid)
library(psych)
library(Matrix)
library(vtable)
pass <- read.csv("data/pass.csv")
```

```{r edit-data, message = F, warning = F, echo=FALSE}
uniqchars <- function(x) unique(strsplit(x, "")[[1]]) 

pass_more <- pass |>
  mutate(true_val = ifelse(time_unit == "years", 31536000*value,
                           ifelse(time_unit == "months", 2592000*value,
                          ifelse(time_unit == "days", 86400*value,
                          ifelse(time_unit == "hours", 3600*value,
                          ifelse(time_unit =="minutes", 60*value,value))))),
         true_val_strength = ifelse(true_val == 1.84, 1,
                                    ifelse(true_val == 11.11, 2,
                                    ifelse(true_val == 111.00, 3, 
                                    ifelse(true_val == 475.20, 4,
                                    ifelse(true_val == 1111.20, 5,
                                    ifelse(true_val == 11124.00,6, 
                                    ifelse(true_val == 12348.00, 7, 
                                    ifelse(true_val== 111456.00, 8, 
                                    ifelse(true_val == 321408, 9, 
                                    ifelse(true_val == 8268480, 10, 11)))))))))),
         category = ifelse(category == "simple-alphanumeric", "alphanumeric", category),
         pass_length = nchar(password),
         value = NULL,
         time_unit = NULL,
         num_digits = str_count(password, "[0-9]"),
         num_letters = str_count(password, "[a-z]"),
         # num_vowels = str_count(password, "[a,e,i,o,u]"),
         num_unique = sapply(strsplit(password, ""), 
                             function(x) length(unique(x)))) |>
  filter(!is.na(rank)) |>
  filter(strength < 11) 

pass_ordered <- pass_more

pass_ordered$category <- with(pass_ordered, 
                              reorder(category, strength, median, na.rm=T))
```

# Introduction

## Research Question and Motivation

In our increasingly technology-oriented world, data security is a pressing and essential topic. As cybercriminals' hacking tools have improved, data leaks at major companies such as Yahoo, Facebook, LinkedIn, Mariott International, Adobe, Bank of America, British Airways, and CVS have compromised billions of users' personal information. In 2022, IBM found that the average data breach in the U.S. cost companies an average of \$9.44 million in lost business, crisis management efforts, and ransom payments. Data breaches can also allow hackers to access users' personal information such as names, addresses, credit card details, and Social Security numbers, which can be used for financial fraud or identity theft. One critical aspect of data security is password strength, which can reduce the risk of cybercriminals guessing users' passwords and acesssing personal information. Given our interset in datasecurity and the topcality of password strength as a key aspect of this subject area, we wanted to explore password data for our project.

Our research question is: How do various password characteristics affect password strength? We measure password strength in two ways: "strength" (which is calculated by an algorithm based on the password's length and complexity and is comparative to the generally bad passwords in the dataset) and the time the password takes to crack by online guessing (a brute force attack that guesses all possible combinations).

## Data Description

| Variable Name     | Type        | Description                                                      |
|------------------|------------------|------------------------------------|
| rank              | numeric     | Popularity in their database of released passwords               |
| password          | character   | Actual text of password                                          |
| category          | categorical | Classification of type of password                               |
| true_val          | double      | Time to crack by online guessing standardized to seconds         |
| true_val_strength | double      | true_val made numeric where 11 is most crack time, 1 is lowest   |
| offline_crack_sec | double      | Time to crack offline in seconds                                 |
| rank_alt          | numeric     | Secondary popularity rank in database of released passwords      |
| font_size         | numeric     | Arbitrary font size Knowledge Is Beautiful used in graphic       |
| strength          | numeric     | Quality of password where 10 is highest, 1 is lowest             |
| pass_length       | numeric     | Length of the password                                           |
| num_digits        | numeric     | Number of digits in the password                                 |
| num_letters       | numeric     | Number of letters in the password                                |
| num_unique        | numeric     | Number of unique characters (letters or numbers in the password) |

Our data come from Tidy Tuesday, originally sourced from Information is Beautiful, a design company that distills data into visualizations and infographics. Information is Beautiful acquired its data on passwords by deep-mining 20 separate data breaches in 2017, including breaches of Facebook, Sony, and Yahoo. The data only includes the 500 most popular passwords, which also tended to be low-strength. Therefore, the `strength` variable indicates password strength in relation to these generally weak passwords.

In the cleaning process, we removed the last seven observations, as all their values were "NA." We also removed observations that had a strength recorded over ten as those may have been miscalculations or strengths that were not standardized to values 1 through 10. From there, we were left with 485 observations. Additionally, we combined the `value` and `time_unit` variables into one time standardized to seconds called `true_val`. Previously, `value` referred to the time to crack by online guessing, and time unit was the time unit to match with that value (seconds, minutes, hours, days, months, or years). Based on `true_val`, we made a new variable called `true_val_strength` for use in ordinal regression. This variable translated `true_val` values to numbers 1-11, since `true_val` values were not actually continuous but rather discrete values (2.17 years, 0.00321 days, etc.). Translating these times to 1-11 also allowed us to better visualize our data, since there was a large gap between observations---some took only seconds to crack, while others took years. Finally, we added four new variables: `pass_length`, `num_digits`, `num_letters`, and `num_unique`. We added these variables because we believe that password length and composition could impact strength.

## Exploratory Data Analysis

Given our prior knowledge of what makes passwords stronger, we chose to focus our exploratory data analysis on the predictors password length and number of unique characters, along with their relationships with other variables in the dataset.

### Summary Statistics:

```{r EDA, message = F, warning = F, echo=FALSE}
pass_more |>
  dplyr::select(-rank) |>
  dplyr::select(-rank_alt) |>
  dplyr::select(-font_size) |>
  dplyr::select(-true_val) |>
  dplyr::select(-offline_crack_sec) |>
st(out = "return",
   summ = c( 'mean(x)', 'median(x)', 'sd(x)', 'min(x)', 'max(x)')) 

## these statistics should have at least 3 decimal places, functions I tried didn't work :(
```

From the table, the average number of digits in a password are 0.464, the average number of letters is 5.718, the average number of unique characters is 5.192, and the average password length is 6.181. In general, this indicates that the most popular passwords in the data leaks used all unique letters and rarely used numbers. In terms of our predictors, the average strength was 6.6, and the average true_val_strength was 8.6, representing an online crack time of about two and a half days. This indicates that the compared to generally weak passwords, the average password in this dataset had a higher-than-average "strength" by both measures. In other words, the distribution of our data under `strength` and `true_val_strength` are left-skewed. An explanation of why we focused on these variables can be found in the methodology section.

### Plots:

```{r EDA-2, message = F, warning = F, echo=FALSE, fig.height=10, fig.width=8}
p1 <- pass_more %>%
  group_by(strength, pass_length) %>%
  summarize(freq = n()) |>
  ggplot(aes(x = pass_length, y = strength)) + 
  geom_point(aes(size = freq)) +
  geom_smooth(method = "lm", se = F) +
  guides(size = "none") + 
  theme_minimal() + 
  labs(x = "Password Length", y = "Strength", 
       title = "Longer Passwords are Typically Stronger", 
       caption = "Figure 1") +
  theme(
      plot.margin = margin(0, 1, 1, 0, "cm")
  )

p2 <- pass_more %>%
  group_by(num_unique, strength, category) %>%
  summarize(freq=n()) |>
  ggplot(aes(x = num_unique, y = strength, color = category, size = freq)) +
  facet_wrap(~category, ncol = 3) + 
  geom_point() +
  theme_minimal() + 
  scale_fill_viridis_d() +
  guides(color = "none", size = "none") + 
  labs(x = "Number of Unique Characters", y = "Strength", 
       title = "Unique Characters Tend To Increase Strength", 
       subtitle = "Grouped by Category",
       caption = "Figure 2") +
    theme(
      plot.margin = margin(0, 1, 0, 0, "cm")
  )

p3<- pass_more |>
  group_by(pass_length, true_val_strength) %>%
  summarize(freq=n()) |>
  ggplot(aes(x = pass_length, y = true_val_strength)) +
  geom_point(aes(size = freq)) +
  geom_smooth(method = "lm", se = F) + 
  theme_minimal() + 
  labs(x = "Password Length", y = "Online Crack Time", 
       title = "Longer Passwords Typically Take Longer",
       subtitle = "crack time represented by numbers 1-10",
       caption = "Figure 3") +
    theme(
      plot.margin = margin(0, 1, 1, 0, "cm")
  )

p4<- pass_more %>%
  group_by(num_unique, true_val_strength, category) %>%
  summarize(freq=n()) |>
  ggplot(aes(x = num_unique, y = true_val_strength, color = category, size = freq)) +
  facet_wrap(~category, ncol = 3) + 
  geom_point() +  
  theme_minimal() + 
  scale_fill_viridis_d() +
  guides(color = "none", alpha = "none") + 
  labs(x = "Number of Unique Characters", y = "Online Crack Time", 
       title = "Unique Characters Tend to Increase Time", 
       subtitle = "Grouped by Category",
       caption = "Figure 4") +
    theme(
      plot.margin = margin(0, 1, 0, 0, "cm")
  )

grid.arrange(p1, p3, p2, p4, ncol = 2, nrow = 2)
```

\pagebreak

Figure 1 demonstrates that there appears to be a positive relationship between password length and the strength variable based on the line of best fit. We can also see this from the data themselves based on how the size of the points change as strength increases. For passwords of length 6, 7, and 8, most passwords have strengths of above 5. The large size of several points associated with password length 6 indicates that, by far, most passwords in this dataset have length 6.

Figure 2 demonstrates that the number of unique characters appears to have a positive relationship with password strength. This relationship holds for all categories, except simple-alphanumeric. Although there appears to be a positive relationship between number of unique terms and password strengths for some passwords in this category, the horizontal line in this plot also shows that some passwords with varying numbers of unique terms have the same password strength. Additionally, the size of the points in the plot demonstrates that some categories of passwords were more popular in our data, especially name, cool-macho, fluffy, and sport.

Figure 3 shows a positive relationship between password length and online crack time (`true_val_strength`), as demonstrated by the positive slope of the line of best fit. In general, longer passwords take longer to crack, and the majority of passwords with online crack time categories of 9 or above are 6 characters or longer. Looking at the distribution of our data, it appears that there should be a stronger positive relationship between password between password length and online crack time, but the outlier at length 9 may have reduced the slope of our line of best fit.

Figure 4 demonstrates that there appears to be a positive relationship between number of unique characters and online crack time. However, whether this trend holds differs by password category. The passwords in the food, nerdy-pop, and sport categories are clustered around high online crack times and do not appear to have any clear pattern. For passwords in the alphanumeric category, the groups of points in the plot that look like two parallel lines with positive slopes are consistent with the general trend of a positive relationship. However, many passwords with 2 or less unique characters have high online crack times, demonstrated by the vertical line at the left of the plot, and one point with 9 unique characters has a very low online crack time.

# Methodology

In terms of our outcome variables, we excluded `offline_crack_sec` because it is merely transformation of `online_crack_sec`. In terms of our predictors, we focused on pass_length, num_digits, num_letters, and num_unique variables. Based on our research and prior knowledge, we believed it was reasonable to focus on these as the most important predictors of password strength. Longer passwords with more varied compositions (unique characters and digits) are typically harder to guess because that increases the options for what the password might look like. Category may also be an indicator of strength when the person or program guesses the most common passwords--passwords that fall into certain categories may be more common and thus easier to crack. We excluded the rank and rank_alt variables because our research question explores what characteristics of passwords make them stronger, and their popularity in data leaks is not necessarily related to their composition and is likely not representative of how popular these passwords are in general either. We excluded the password variable, since the text of the password could not be used as a predictor. However, the composition of the password is encompassed in the predictors we use. We did not use `num_letters` in our model because the ordinal model could not handle more than 4 variables given that our dataset only had 500 observations. This should not affect our analysis, since the number of letters can be derived from the number of digits because no passwords included special characters.

In our analysis, we run two ordinal regressions, one on strength, and one on online crack time. The strength variable is an ordered number 1-10, in order of increasing password strength, making an ordinal model the best fit. The strength variable meets the ordinal assumption of proportional odds, since it is reasonable to assume that one-unit changes in each predictor have the same conditional relationship with being in each strength category. For example, the strength variable is calculated in part based on the number of unique characters, and each one-unit increase in the number of unique characters has the same conditional relationship with being in each strength category. Ordinal regression is also a good fit for the `true_val_strength` variable, which is ordered in increasing order of time to crack the password. The variable also meets the proportional odds assumption, as it is reasonable to assume that one-unit changes in each predictor have the same conditional relationship with being in each true_val_strength category, by similar reasoning as the strength variable.

We also did logistic regressions for both these response variables, where they each had a threshold of a value of 8 or above for being considered "strong". This allows us to bolster our ordinal models to see if the predictor variables they pick are similar. The assumption to meet would be linearity and independence. In terms of linearity, we would show that our continuous variables are roughly linearly related to the log odds of the response. Given the limited values of our continuous variables, and limited observations, it was not possible to create such plots as the `num_groups` parameter would have to be set to two, which would make the plot irrelevant at that point, so for the logistic part of our analysis, we assume linearity. Additionally, for independence the observations shouldn't be related to each other because people chose their passwords based on what they wanted and not what other people have said. There are no groupings so it is hard to see how one observation would inform us about another.

```{r methods-log-plots, message = F, warning = F, echo=FALSE}

pass_log_strong <- pass_more |>
  mutate(
    strong = ifelse(strength >= 8, 1, 0)
  )

pass_log_true_strong <- pass_more |>
  mutate(
    true_strong = ifelse(true_val_strength >= 8, 1, 0)
  )


# emplogitplot1(strong ~ num_unique,
#               data = pass_log_strong,
#               ngroups = 3)
# 
# emplogitplot1(strong ~ pass_length,
#               data = pass_log_strong,
#               ngroups = 2)
# 
# emplogitplot1(strong ~ num_digits,
#               data = pass_log_strong,
#               ngroups = 2)


```

\footnotesize

Ordinal Model for Strength and True Val Strength Respectively:

```{r methods-ordinal,  message = F, warning = F, echo=FALSE}


m1 <- polr(factor(strength) ~ . - password - true_val - true_val_strength - offline_crack_sec - rank - num_letters - rank_alt - font_size, data = pass_more, model = FALSE)
sum1 <- capture.output(summary(m1))
Start = grep("Coefficients:", sum1)
End   = grep("num_unique", sum1)
print(as.data.frame(sum1[Start:End]), row.names=FALSE, quote = FALSE)

# temp = capture.output(summary(model))
# Start = grep("Random effects", temp)
# End   = grep("Number of obs", temp)
# print(unname(temp[Start:End]))

m2 <- polr(factor(true_val_strength) ~ . - password - num_letters - offline_crack_sec - strength - rank - true_val - rank_alt - font_size, data = pass_more, model = FALSE)

sum2 <- capture.output(summary(m2))
Start = grep("Coefficients:", sum2)
End   = grep("num_unique", sum2)
print(as.data.frame(sum2[Start:End]), row.names=FALSE, quote = FALSE)
```

Logistic Model for Strength and True Value Strength Respectively

```{r logistic, message = F, warning = F, echo=FALSE}

strong_mod <- glm(strong ~ . - password - num_letters - rank_alt - font_size - offline_crack_sec - strength - rank - true_val - true_val_strength,
  data = pass_log_strong,
  family = "binomial"
)

tidy(strong_mod)

true_strong_mod <- glm(true_strong ~ . - password - num_letters - offline_crack_sec - strength - rank - true_val - true_val_strength - rank_alt - font_size,
  data = pass_log_true_strong,
  family = "binomial"
)

tidy(true_strong_mod)

```

```{r evaluate-methods, message = F, warning = F, echo=FALSE}
#| layout-ncol: 2

strong_mod_aug <- augment(strong_mod)

strong_mod_aug <- strong_mod_aug %>% 
  mutate(prob = exp(.fitted)/(1 + exp(.fitted)),
         pred_strong = ifelse(prob > 0.5, "Strong", "Not Strong")) %>% 
  dplyr::select(.fitted, prob, pred_strong, strong)

true_strong_mod_aug <- augment(true_strong_mod)

true_strong_mod_aug <- true_strong_mod_aug %>% 
  mutate(prob = exp(.fitted)/(1 + exp(.fitted)),
         pred_true_strong = ifelse(prob > 0.5, "Strong", "Not Strong")) %>% 
  dplyr::select(.fitted, prob, pred_true_strong, true_strong)

knitr::kable(table(strong_mod_aug$pred_strong, strong_mod_aug$strong), caption = "Predictions for Strength")
knitr::kable(table(true_strong_mod_aug$pred_true_strong, true_strong_mod_aug$true_strong), caption = "Predictions for True Strength")
```

```{r auc, message = F, warning = F, echo=FALSE}
#| layout-ncol: 2

strong_auc <- strong_mod_aug %>% 
  roc_auc(
    truth = as.factor(strong),
    prob, 
    event_level = "second"
  )
true_strong_auc <- true_strong_mod_aug %>% 
  roc_auc(
    truth = as.factor(true_strong),
    prob, 
    event_level = "second"
  ) 

knitr::kable(strong_auc, caption = "AUC for ROC of Strength")
knitr::kable(true_strong_auc, caption = "AUC for ROC of True Strength")
```

\normalsize

# Results

Our first ordinal model shows the relationship between the predictors category, password length, number of digits, and number of unique characters and the log-odds of being in the next-highest strength category. The predictors with the greatest impact on strength, as indicated by the magnitude of their slopes, are number of unique characters and being categorized as food-related. The number of digits also had a relatively high slope magnitude, and password length had a small slope magnitude. It may seem strange that `num_digits` and `password_length` have negative slopes. However, this is because our model controls for the number of unique characters: a unique additional digit or character (which would make the password longer) is predicted to increase the odds of being in the next-highest strength category, but if the additional digit or character is not unique, it is predicted to decrease those odds. Although we do not conduct a formal hypothesis test, the high-magnitude t-values associated with the number of digits, being in the food category, and especially the number of unique characters (t value of 17.147) suggest that these predictors have a meaningful relationship with password strength and are important to include in a model predicting strength.

In terms of what the key coefficients from our model mean in context, the slope for `categoryfood` indicates that while controlling for all other predictors, our model predicts being in the food category to decrease a password's odds of being in the next-highest strength category (1 to 2, or 2 to 3, for example) by a multiplicative factor of 0.049. The slope for `num_unique` indicates that while controlling for all other predictors, as the number of unique characters in the password increases by 1, our model predicts the odds of being in the next-highest strength category to increase by 40.23 times.

Our second ordinal model shows the relationship between the same predictors and `true_val_strength`, which again represents an online crack time, represented by values 1-10. The predictors with the largest impact on strength, as indicated by the magnitude of their slopes are password length, number of digits, and being in the rebellious-rude category. The low magnitude slope for the number of unique characters makes sense in this model because if the computer is guessing every possible character every time, then uniqueness does not matter. The high-magnitude t-values associated with the number of digits (t value of -9.447) and password length (10.429) indicate that these predictors have a meaningful relationship with online crack time.

In terms of what the key coefficients from our model mean in context, the slope for `categoryrebellious-rude` indicates that while controlling for all other predictors, our model predicts being in the rebellious-rude category to increase a password's odds of being in the next-highest strength category by 24.19 times. The slope for `pass_length` means that while controlling for all other predictors, as the password length increases by 1 character or digit, our model predicts the odds of being in the next-highest strength category to increase by 201,894.4 times.

# Discussion

## Conclusions

Our two ordinal models suggest that different characteristics improve password strength depending on how password strength is defined. To increase the traditional, numeric measure of password strength, it may be most helpful to have more unique characters. Additionally, it may be helpful to not have a food-related password, as these passwords may be more easily guessed. To increase the time it takes to crack the password online, it appears most important to have a longer password, regardless of its composition. This makes sense based on the mechanism of online guessing, which is brute force, or trying all possible combinations.

*In this section you'll include a summary of what you have learned about your research question along with statistical arguments supporting your conclusions.*

## Limitations and Future Research

To reiterate, this data holds the 500 most common passwords from a data leak, and so since they are the most common, most are relatively simple and not strong to begin with. As such, a high value for the strength variable means only that the password was good compared to others in the dataset. Therefore, our data are not representative of all passwords in data breaches, or all passwords overall. In fact, most passwords nowadays are forced to be inherently strong with a minimum character, digit, and special character limit, and most of these leaked passwords did not follow these rules. To improve upon this analysis (although this may not be totally ethical), it would help to have a more representative sample of passwords from a data braech (as opposed to just the most popular ones) or a more representative sample of passwords overall. Future work could use these kinds of more representative samples. Additionally, future work could explore which characteristics of passwords make them stronger against other hacking techniques, such as more advanced AI algorithms. Given that data security is becoming a more pressing issue with technological advances, the avenues for future research remain both vast and topical.

# Sources

External research: https://www.keepersecurity.com/blog/2022/09/14/why-is-password-security-important/ https://www.bleepingcomputer.com/news/security/the-benefits-of-making-password-strength-more-transparent/ https://www.ibm.com/downloads/cas/3R8N1DZJ

Data source: https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-01-14/readme.md
